### PARTE C
1. FRECUENCIA DE NYQUIST PARA LA SEÑAL GENERADA!
   
   La señal OCG considerada presenta una frecuencia fundamental de 50 Hz (dato consltado).De acuerdo con el teorema de muestreo de Nyquist, la frecuencia mínima 
   de muestreo debe ser al menos el doble de la máxima frecuencia presente en la señal, con el fin de evitar el solapamiento espectral (aliasing) y garantizar 
   una correcta reconstrucción. Por esta razón, la frecuencia de Nyquist para esta señal corresponde a 100 Hz.

2. DIGITALIZACIÓN DE LA SEÑAL USANDO 4 VECES LA FRECUENCIA DE MUESTREO!

   ![Diagrama de flujo](https://github.com/TomasCobos-rgb/INFORME-2-LAB-SE-ALES-/blob/main/Im%C3%A1genes%20Parte%20A/Grafica%20Diagrama%20de%20Flujo%20Profesional%20Beige%20(3).png?raw=true)

   Para la digitalización de la señal se utilizo el siguiente script de la docente Carolina Corredor:
   
``` Python
# Librerias
import nidaqmx
from nidaqmx.constants import AcquisitionType
import matplotlib.pyplot as plt
import numpy as np
import pandas as pd   # Librería para guardar en CSV

```

``` Python
Adquisición de la señal por tiempo definido

fs = 400          # Frecuencia de muestreo en Hz
duracion = 5        # Duración de la medición en segundos
dispositivo = 'Dev1/ai0'  # Canal DAQ

total_muestras = int(fs * duracion)

with nidaqmx.Task() as task:
    # Configuración del canal
    task.ai_channels.add_ai_voltage_chan(dispositivo)

    # Configuración del muestreo
    task.timing.cfg_samp_clk_timing(
        fs,
        sample_mode=AcquisitionType.FINITE,
        samps_per_chan=total_muestras
    )

```

``` Python
  # Captura de la señal
    senal = task.read(number_of_samples_per_channel=total_muestras)
```

``` Python
# Procesamiento y guardado

# Crear vector de tiempo
t = np.arange(len(senal)) / fs

# Crear DataFrame con pandas
df = pd.DataFrame({
    'Tiempo (s)': t,
    'Voltaje (mV)': senal
})

# Guardar a CSV
nombre_archivo = 'senal_daq_400fm.csv'
df.to_csv(nombre_archivo, index=False, encoding='utf-8-sig')
print(f"✅ Datos guardados en '{nombre_archivo}'")

#%% Graficar la señal
plt.plot(t, senal)
plt.axis([0, duracion, -10, 10])
plt.grid()
plt.title(f"fs={fs}Hz, duración={duracion}s, muestras={len(senal)}")
plt.xlabel("Tiempo (s)")
plt.ylabel("Voltaje (mV)")
plt.show()
```
### CARACTERIZACIÓN DE LA SEÑAL 

![Diagrama de flujo](https://github.com/TomasCobos-rgb/INFORME-2-LAB-SE-ALES-/blob/main/Im%C3%A1genes%20Parte%20A/Grafica%20Diagrama%20de%20Flujo%20Profesional%20Beige%20(4).png?raw=true)

``` Python
import pandas as pd
import matplotlib.pyplot as plt

# si está separado por comas
df = pd.read_csv("senal_daq_400fm.csv", sep=",")

print(df.head())      # muestra las primeras filas
print(df.columns)     # muestra los nombres de columnas

# Graficar
plt.plot(df['Tiempo (s)'], df['Voltaje (V)'])
plt.title("Señal digitalizada ")
plt.xlabel("Tiempo (s)")
plt.ylabel("Voltaje (V)")
plt.grid()
plt.show()

# Calcular estadísticos
media = np.mean(senal)
mediana = np.median(senal)
desv_std = np.std(senal)
maximo = np.max(senal)
minimo = np.min(senal)

print(f"Media: {media:.4f} V")
print(f"Mediana: {mediana:.4f} V")
print(f"Desviación estándar: {desv_std:.4f} V")
print(f"Máximo: {maximo:.4f} V")
print(f"Mínimo: {minimo:.4f} V")
``` 

### CLASIFICACIÓN DE LA SEÑAL SEGUN SU TIPO

### GRÁFICA
![](https://github.com/TomasCobos-rgb/INFORME-2-LAB-SE-ALES-/blob/main/Im%C3%A1genes%20Parte%20A/imagen_2025-09-09_195036244.png?raw=true)

### Determinística / Aleatoria
Aunque se ve un patrón (picos periódicos que corresponden a latidos), la señal real tiene ruido, variaciones y no se puede predecir con exactitud.
Se clasifica como aleatoria.

### Periódica / Aperiódica
El corazón late de manera rítmica, por lo que hay una cuasi-periodicidad (los picos se repiten cada cierto tiempo), pero no es perfectamente igual en cada ciclo.
Se clasifica como aperiódica (cuasi-periódica).
### Analógica / Digital
En su origen (el voltaje del cuerpo) es una señal analógica, pero como ya la muestras en tu PC (después del ADC) está discretizada en tiempo y cuantizada en amplitud.
La señal en la gráfica es digital.



## 4. Transformada de Fourier

![Diagrama de flujo](https://github.com/TomasCobos-rgb/INFORME-2-LAB-SE-ALES-/blob/main/Im%C3%A1genes%20Parte%20A/Grafica%20Diagrama%20de%20Flujo%20Profesional%20Beige%20(6).png?raw=true)

   La Transformada de Fourier analizar señales transformándolas del dominio del tiempo al dominio de la frecuencia.


``` Python
df = pd.read_csv("/content/drive/MyDrive/senal_daq_400fmdef.csv")

dt = t[1] - t[0]   # diferencia entre muestras
fs = 1 / dt        # frecuencia de muestreo
N = len(x)         # número de muestras

#Calculo de la transformada de Fourier
X = np.fft.fft(x) / N    #Divir en N para normalizar los datos
freqs = np.fft.fftfreq(N, d=dt)
PSD = (1/(fs*N)) * (np.abs(X)**2)
PSD[1:-1] *= 2

#Gráfica de la tranformada de Fourier
plt.figure(figsize=(10,4))
plt.plot(freqs, X_mag)
plt.title("Transformada de Fourier (Magnitud)")
plt.xlabel("Frecuencia [Hz]")
plt.ylabel("Amplitud [mV]")  # Cambia a [V] si corresponde
plt.grid()
plt.show()

```
![Gráfica de la Transformada de Fourier](https://github.com/TomasCobos-rgb/INFORME-2-LAB-SE-ALES-/blob/5f4672b112f2bc2e6317a7efc16f58fb44492fc8/Im%C3%A1genes%20Parte%20A/Transformada%20de%20Fourier.png)


## b) Densidad espectral
Función matemática que describe cómo se distribuye la potencia de una señal (o un proceso aleatorio) a través de las distintas frecuencias que la componen.
``` Python
# Nos quedamos solo con la mitad positiva
mask = freqs >= 0
freqs = freqs[mask]
X = X[mask]
X_mag = np.abs(X)
PSD = PSD[mask]   


PSD_norm = PSD / np.sum(PSD)  # normalizamos para usarlo como distribución
f_mean = np.sum(freqs * PSD_norm)
f_median = freqs[np.cumsum(PSD_norm) >= 0.5][0]
f_std = np.sqrt(np.sum(((freqs - f_mean)**2) * PSD_norm))


plt.figure(figsize=(10,4))
plt.semilogy(freqs, PSD)
plt.title("Densidad Espectral de Potencia (PSD)")
plt.xlabel("Frecuencia [Hz]")
plt.ylabel("PSD [V^2/Hz]")  
plt.grid()
plt.show()

```
![Gráfica de la Densidad espectral](https://github.com/TomasCobos-rgb/INFORME-2-LAB-SE-ALES-/blob/3da4b001baeb15108e276e55302dd1d1761eb778/Im%C3%A1genes%20Parte%20A/Densidad%20espectral.png)

## c) Estadísticos en el dominio de la frecuencia e histograma
```python
# Mitad positiva
mask = freqs >= 0
freqs = freqs[mask]
X = X[mask]
X_mag = np.abs(X)
PSD = PSD[mask]   

#Estadísticos en el dominio de la frecuencia
PSD_norm = PSD / np.sum(PSD)  # normalizamos para usarlo como distribución
f_mean = np.sum(freqs * PSD_norm)
f_median = freqs[np.cumsum(PSD_norm) >= 0.5][0]
f_std = np.sqrt(np.sum(((freqs - f_mean)**2) * PSD_norm))

##  Histograma de frecuencias
plt.figure(figsize=(8,4))
plt.hist(freqs, bins=50, weights=PSD_norm)
plt.title("Histograma de Frecuencias (ponderado por PSD)")
plt.xlabel("Frecuencia [Hz]")
plt.ylabel("Probabilidad")
plt.grid()
plt.show()

print("Estadísticos en el dominio de la frecuencia:")
print(f"Frecuencia media: {f_mean:.2f} Hz")
print(f"Frecuencia mediana: {f_median:.2f} Hz")
print(f"Desviación estándar: {f_std:.2f} Hz")
```
![Historgrama](https://github.com/TomasCobos-rgb/INFORME-2-LAB-SE-ALES-/blob/861d914653e223ac6585068da6eb3ce040fd75a1/Im%C3%A1genes%20Parte%20A/Histograma%20PSD.png)
```python
Estadísticos en el dominio de la frecuencia:
Frecuencia media: 9.45 Hz
Frecuencia mediana: 4.00 Hz
Desviación estándar: 22.05 Hz
```
