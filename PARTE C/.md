### PARTE C
1. FRECUENCIA DE NYQUIST PARA LA SEÑAL GENERADA!
   
   La señal OCG considerada presenta una frecuencia fundamental de 50 Hz (dato consltado).De acuerdo con el teorema de muestreo de Nyquist, la frecuencia mínima 
   de muestreo debe ser al menos el doble de la máxima frecuencia presente en la señal, con el fin de evitar el solapamiento espectral (aliasing) y garantizar 
   una correcta reconstrucción. Por esta razón, la frecuencia de Nyquist para esta señal corresponde a 100 Hz.

2. DIGITALIZACION DE LA SEÑAL USANDO 4 VECES LA FRECUENCIA DE MUESTREO!

   Para la digitalización de la señal se utilizo el siguiente script de la docente Carolina Corredor:
   
``` Python
# Librerias
import nidaqmx
from nidaqmx.constants import AcquisitionType
import matplotlib.pyplot as plt
import numpy as np
import pandas as pd   # Librería para guardar en CSV

```

``` Python
Adquisición de la señal por tiempo definido

fs = 400          # Frecuencia de muestreo en Hz
duracion = 5        # Duración de la medición en segundos
dispositivo = 'Dev1/ai0'  # Canal DAQ

total_muestras = int(fs * duracion)

with nidaqmx.Task() as task:
    # Configuración del canal
    task.ai_channels.add_ai_voltage_chan(dispositivo)

    # Configuración del muestreo
    task.timing.cfg_samp_clk_timing(
        fs,
        sample_mode=AcquisitionType.FINITE,
        samps_per_chan=total_muestras
    )

```

``` Python
  # Captura de la señal
    senal = task.read(number_of_samples_per_channel=total_muestras)
```

``` Python
# Procesamiento y guardado

# Crear vector de tiempo
t = np.arange(len(senal)) / fs

# Crear DataFrame con pandas
df = pd.DataFrame({
    'Tiempo (s)': t,
    'Voltaje (mV)': senal
})

# Guardar a CSV
nombre_archivo = 'senal_daq_400fm.csv'
df.to_csv(nombre_archivo, index=False, encoding='utf-8-sig')
print(f"✅ Datos guardados en '{nombre_archivo}'")

#%% Graficar la señal
plt.plot(t, senal)
plt.axis([0, duracion, -10, 10])
plt.grid()
plt.title(f"fs={fs}Hz, duración={duracion}s, muestras={len(senal)}")
plt.xlabel("Tiempo (s)")
plt.ylabel("Voltaje (mV)")
plt.show()
```
### CARACTERIZACION DE LA SEÑAL 
``` Python
import pandas as pd
import matplotlib.pyplot as plt

# si está separado por comas
df = pd.read_csv("senal_daq_400fm.csv", sep=",")

print(df.head())      # muestra las primeras filas
print(df.columns)     # muestra los nombres de columnas

# Graficar
plt.plot(df['Tiempo (s)'], df['Voltaje (V)'])
plt.title("Señal digitalizada ")
plt.xlabel("Tiempo (s)")
plt.ylabel("Voltaje (V)")
plt.grid()
plt.show()

# Calcular estadísticos
media = np.mean(senal)
mediana = np.median(senal)
desv_std = np.std(senal)
maximo = np.max(senal)
minimo = np.min(senal)

print(f"Media: {media:.4f} V")
print(f"Mediana: {mediana:.4f} V")
print(f"Desviación estándar: {desv_std:.4f} V")
print(f"Máximo: {maximo:.4f} V")
print(f"Mínimo: {minimo:.4f} V")
``` 

### CLASIFICACION DE LA SEÑAL SEGUN SU TIPO

### GRAFICA
![](https://github.com/TomasCobos-rgb/INFORME-2-LAB-SE-ALES-/blob/main/Im%C3%A1genes%20Parte%20A/imagen_2025-09-09_195036244.png?raw=true)

### Determinística / Aleatoria
Aunque se ve un patrón (picos periódicos que corresponden a latidos), la señal real tiene ruido, variaciones y no se puede predecir con exactitud.
Se clasifica como aleatoria.

### Periódica / Aperiódica
El corazón late de manera rítmica, por lo que hay una cuasi-periodicidad (los picos se repiten cada cierto tiempo), pero no es perfectamente igual en cada ciclo.
Se clasifica como aperiódica (cuasi-periódica).
### Analógica / Digital
En su origen (el voltaje del cuerpo) es una señal analógica, pero como ya la muestras en tu PC (después del ADC) está discretizada en tiempo y cuantizada en amplitud.
La señal en la gráfica es digital.



4. Transformada de Fourier!
``` Python
df = pd.read_csv("/content/drive/MyDrive/senal_daq_400fmdef.csv")

#Calculo de la transformada de Fourier
X = np.fft.fft(x) / N    #Divir en N para normalizar los datos
freqs = np.fft.fftfreq(N, d=dt)
PSD = (1/(fs*N)) * (np.abs(X)**2)
PSD[1:-1] *= 2

#Gráfica de la tranformada de Fourier
plt.figure(figsize=(10,4))
plt.plot(freqs, X_mag)
plt.title("Transformada de Fourier (Magnitud)")
plt.xlabel("Frecuencia [Hz]")
plt.ylabel("Amplitud [mV]")  # Cambia a [V] si corresponde
plt.grid()
plt.show()

```
